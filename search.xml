<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>初次见面</title>
    <url>/2020/09/17/%E5%88%9D%E6%AC%A1%E8%A7%81%E9%9D%A2/</url>
    <content><![CDATA[<p>你好！这里是阿欢同学的博客。<br>这里将分享我的学习笔记和一些生活趣事。<br>请多多指教！</p>
]]></content>
      <categories>
        <category>杂言</category>
      </categories>
      <tags>
        <tag>琐碎的事</tag>
      </tags>
  </entry>
  <entry>
    <title>Weapon_of_Aphelios</title>
    <url>/2023/03/20/Weapon-of-Aphelios/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>：这个名字好中二的样子</p>
<p>：就是很中二的东西<br>而且“美而无用”</p>
</blockquote>
<span id="more"></span>
<hr>
<p><strong>项目路径：</strong><a href="https://github.com/KayanYem/Weapon_of_Aphelios">Weapon_of_Aphelios</a></p>
<p><strong>硬件部分：</strong> WS2812 LED灯（X5），使用STM32芯片，按键（红、蓝）。</p>
<p><strong>实现功能：</strong></p>
<ul>
<li>红色按键：最右边的灯移到最左，其余四个依次向右移一位。</li>
<li>蓝色按键：最右边的灯不动，右边第二个灯移到最左，其余四个依次向右移一位。</li>
</ul>
<p><strong>展示</strong></p>
<p><img src="https://github.com/KayanYem/Weapon_of_Aphelios/5.DISPLAY/pic1.jpg" alt="图1"><br><img src="https://github.com/KayanYem/Weapon_of_Aphelios/5.DISPLAY/pic2.jpg" alt="图2"><br><img src="https://github.com/KayanYem/Weapon_of_Aphelios/5.DISPLAY/pic3.jpg" alt="图3"><br><img src="https://github.com/KayanYem/Weapon_of_Aphelios/5.DISPLAY/video.gif" alt="video"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">230225 调试</span><br><span class="line">1. 需要修改硬件电路</span><br><span class="line">2. 购买的按钮与设计的不同（已修改</span><br><span class="line">3. LED灯电路有误，电容应该接电源和接地（已修改</span><br><span class="line">4. 考虑是否更换供电方案（没有更换</span><br><span class="line"></span><br><span class="line">230320 完整装配</span><br><span class="line">1. 3D打印壳体透光效果不太好</span><br><span class="line">2. 整体装配后体积较大</span><br><span class="line">3. 壳体设计考虑不足导致装配麻烦</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>小项目</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习</title>
    <url>/2023/01/20/Git%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>Git学习笔记</p>
<span id="more"></span>

<hr>
<h2 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h2><blockquote>
<p>参考 <a href="https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ">https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ</a></p>
</blockquote>
<h4 id="启动Git"><a href="#启动Git" class="headerlink" title="启动Git"></a>启动Git</h4><ul>
<li>Git Bash：Unix与Linux风格的命令行，使用最多，推荐最多</li>
<li>Git CMD：Windows风格的命令行</li>
<li>Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</li>
</ul>
<h4 id="常用Linux命令"><a href="#常用Linux命令" class="headerlink" title="常用Linux命令"></a>常用Linux命令</h4><ul>
<li>cd : 改变目录。</li>
<li>cd . . 回退到上一个目录，直接cd进入默认目录</li>
<li>pwd : 显示当前所在的目录路径。</li>
<li>ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</li>
<li>touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</li>
<li>rm:  删除一个文件, rm index.js 就会把index.js文件删除。</li>
<li>mkdir:  新建一个目录,就是新建一个文件夹。</li>
<li>rm -r :  删除一个文件夹, rm -r src 删除src目录<br><code>rm -rf / 切勿在Linux中尝试！删除电脑中全部文件！</code></li>
<li>mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</li>
<li>reset 重新初始化终端/清屏。</li>
<li>clear 清屏。</li>
<li>history 查看命令历史。</li>
<li>help 帮助。</li>
<li>exit 退出。</li>
<li>#表示注释</li>
</ul>
<p><strong>$ help</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GNU bash, version 4.4.23(1)-release (x86_64-pc-msys)</span><br><span class="line">These shell commands are defined internally.  Type `help&#x27; to see this list.</span><br><span class="line">Type `help name&#x27; to find out more about the function `name&#x27;.</span><br><span class="line">Use `info bash&#x27; to find out more about the shell in general.</span><br><span class="line">Use `man -k&#x27; or `info&#x27; to find out more about commands not in this list.</span><br><span class="line"></span><br><span class="line">A star (*) next to a name means that the command is disabled.</span><br><span class="line"></span><br><span class="line"> job_spec [&amp;]                            history [-c] [-d offset] [n] or hist&gt;</span><br><span class="line"> (( expression ))                        if COMMANDS; then COMMANDS; [ elif C&gt;</span><br><span class="line"> . filename [arguments]                  jobs [-lnprs] [jobspec ...] or jobs &gt;</span><br><span class="line"> :                                       kill [-s sigspec | -n signum | -sigs&gt;</span><br><span class="line"> [ arg... ]                              let arg [arg ...]</span><br><span class="line"> [[ expression ]]                        local [option] name[=value] ...</span><br><span class="line"> alias [-p] [name[=value] ... ]          logout [n]</span><br><span class="line"> bg [job_spec ...]                       mapfile [-d delim] [-n count] [-O or&gt;</span><br><span class="line"> bind [-lpsvPSVX] [-m keymap] [-f file&gt;  popd [-n] [+N | -N]</span><br><span class="line"> break [n]                               printf [-v var] format [arguments]</span><br><span class="line"> builtin [shell-builtin [arg ...]]       pushd [-n] [+N | -N | dir]</span><br><span class="line"> caller [expr]                           pwd [-LPW]</span><br><span class="line"> case WORD in [PATTERN [| PATTERN]...)&gt;  read [-ers] [-a array] [-d delim] [-&gt;</span><br><span class="line"> cd [-L|[-P [-e]] [-@]] [dir]            readarray [-n count] [-O origin] [-s&gt;</span><br><span class="line"> command [-pVv] command [arg ...]        readonly [-aAf] [name[=value] ...] o&gt;</span><br><span class="line"> compgen [-abcdefgjksuv] [-o option] [&gt;  return [n]</span><br><span class="line"> complete [-abcdefgjksuv] [-pr] [-DE] &gt;  select NAME [in WORDS ... ;] do COMM&gt;</span><br><span class="line"> compopt [-o|+o option] [-DE] [name ..&gt;  set [-abefhkmnptuvxBCHP] [-o option-&gt;</span><br><span class="line"> continue [n]                            shift [n]</span><br><span class="line"> coproc [NAME] command [redirections]    shopt [-pqsu] [-o] [optname ...]</span><br><span class="line"> declare [-aAfFgilnrtux] [-p] [name[=v&gt;  source filename [arguments]</span><br><span class="line"> dirs [-clpv] [+N] [-N]                  suspend [-f]</span><br><span class="line"> disown [-h] [-ar] [jobspec ... | pid &gt;  test [expr]</span><br><span class="line"> echo [-neE] [arg ...]                   time [-p] pipeline</span><br><span class="line"> enable [-a] [-dnps] [-f filename] [na&gt;  times</span><br><span class="line"> eval [arg ...]                          trap [-lp] [[arg] signal_spec ...]</span><br><span class="line"> exec [-cl] [-a name] [command [argume&gt;  true</span><br><span class="line"> exit [n]                                type [-afptP] name [name ...]</span><br><span class="line"> export [-fn] [name[=value] ...] or ex&gt;  typeset [-aAfFgilnrtux] [-p] name[=v&gt;</span><br><span class="line"> false                                   ulimit [-SHabcdefiklmnpqrstuvxPT] [l&gt;</span><br><span class="line"> fc [-e ename] [-lnr] [first] [last] o&gt;  umask [-p] [-S] [mode]</span><br><span class="line"> fg [job_spec]                           unalias [-a] name [name ...]</span><br><span class="line"> for NAME [in WORDS ... ] ; do COMMAND&gt;  unset [-f] [-v] [-n] [name ...]</span><br><span class="line"> for (( exp1; exp2; exp3 )); do COMMAN&gt;  until COMMANDS; do COMMANDS; done</span><br><span class="line"> function name &#123; COMMANDS ; &#125; or name &gt;  variables - Names and meanings of so&gt;</span><br><span class="line"> getopts optstring name [arg]            wait [-n] [id ...]</span><br><span class="line"> hash [-lr] [-p pathname] [-dt] [name &gt;  while COMMANDS; do COMMANDS; done</span><br><span class="line"> help [-dms] [pattern ...]               &#123; COMMANDS ; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Git必要配置"><a href="#Git必要配置" class="headerlink" title="Git必要配置"></a>Git必要配置</h4><ul>
<li>查看配置 <code>Git config -l</code></li>
<li>查看系统config <code>git config --system --list</code></li>
<li>查看当前用户（global）配置 <code>git config --global --list</code></li>
</ul>
<p>设置用户名与邮箱</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;rjx&quot;  #名称</span><br><span class="line">git config --global user.email 2583488596@qq.com   #邮箱</span><br></pre></td></tr></table></figure>

<h4 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h4><h6 id="创建工作目录与常用指令"><a href="#创建工作目录与常用指令" class="headerlink" title="创建工作目录与常用指令"></a>创建工作目录与常用指令</h6><ul>
<li>在工作目录中添加、修改文件 <code>UserMapper.xml</code></li>
<li>将需要进行版本管理的文件放入暂存区域 <code>git add</code></li>
<li>将暂存区域的文件提交到git仓库 <code>git commit</code></li>
</ul>
<h6 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h6><ul>
<li><p>创建全新的仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure>
</li>
<li><p>克隆远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 克隆一个项目和它的整个代码历史(版本信息)</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>遇到一些问题</p>
<ul>
<li><a href="https://blog.csdn.net/natahew/article/details/81387885">https://blog.csdn.net/natahew/article/details/81387885</a></li>
<li><code>http</code>改为<code>ssh</code></li>
</ul>
<h4 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h4><table>
<thead>
<tr>
<th>命令名称</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td>git branch 分支名</td>
<td align="left">创建分支</td>
</tr>
<tr>
<td>git branch -v</td>
<td align="left">查看分支</td>
</tr>
<tr>
<td>git checkout 分支名</td>
<td align="left">切换分支</td>
</tr>
<tr>
<td>git clone 远程地址</td>
<td align="left">把指定的分支合并到当前分支上</td>
</tr>
</tbody></table>
<h4 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h4><ul>
<li><code>git add</code>把文件设置为跟踪状态，参与版本控制，添加到暂存区</li>
<li><code>git rm</code>把文件移出版本库</li>
<li><code>git checkout</code>移除暂存区文件</li>
<li><code>git commit</code>提交暂存状态文件</li>
</ul>
<h5 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h5><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p>
<ul>
<li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li>
<li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li>
<li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li>
<li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li>
</ul>
<h5 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#指定查看文件状态</span></span><br><span class="line">git status [filename]</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看所有状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加所有文件到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment">#提交暂存区中的内容到本地仓库</span></span><br><span class="line">git commit -m <span class="string">&quot;消息内容&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h5><p>在主目录下建立”.gitignore”文件，此文件有如下规则：</p>
<ol>
<li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li>
<li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li>
<li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li>
<li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li>
<li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*.txt        <span class="comment">#忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span></span><br><span class="line">!lib.txt     <span class="comment">#但lib.txt除外</span></span><br><span class="line">/temp        <span class="comment">#仅忽略项目根目录下的TODO文件,不包括其它目录temp</span></span><br><span class="line">build/       <span class="comment">#忽略build/目录下的所有文件</span></span><br><span class="line">doc/*.txt    <span class="comment">#会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="GitHub操作"><a href="#GitHub操作" class="headerlink" title="GitHub操作"></a>GitHub操作</h4><h5 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h5><h5 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h5><table>
<thead>
<tr>
<th>命令名称</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td>git remote -v</td>
<td align="left">查看当前所有远程地址别名</td>
</tr>
<tr>
<td>git remote add 别名 远程地址</td>
<td align="left">起别名</td>
</tr>
<tr>
<td>git push 别名 分支</td>
<td align="left">推送本地分支上的内容到远程仓库</td>
</tr>
<tr>
<td>git clone 远程地址</td>
<td align="left">将远程仓库的内容克隆到本地</td>
</tr>
<tr>
<td>git pull 远程库地址别名 远程分支名</td>
<td align="left">将远程仓库对于分支最新内容拉下来后与 当前本地分支直接合并</td>
</tr>
</tbody></table>
<ul>
<li><p>创建远程仓库别名<br><strong>基本语法：</strong><br><code>git remote -v</code>；查看当前所有远程地址别名<br><code>git remote add 别名 远程地址</code></p>
</li>
<li><p>推送本地分支到远程仓库<br><strong>基本语法</strong><br><code>git push 别名 分支</code></p>
</li>
<li><p>克隆远程仓库到本地<br><strong>基本语法</strong><br><code>git clone 远程地址</code></p>
</li>
<li><p>邀请加入团队</p>
</li>
<li><p>拉取远程库内容<br><strong>基本语法</strong><br><code>git pull 远程库地址别名 远程分支名</code></p>
</li>
<li><p>更改远程库地址</p>
<ul>
<li><p><strong>方法一</strong>通过命令直接修改远程仓库地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote 查看所有远程仓库</span><br><span class="line">git remote xxx 查看指定远程仓库地址</span><br><span class="line">git remote set-url origin 你新的远程仓库地址</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>方法二</strong>先删除在添加你的远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin 你的新远程仓库地址</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法三</strong>直接修改你本地的.git文件</p>
<blockquote>
<p>这里需要注意的问题是需要进入你的项目目录中<br>例如：你的项目名为test，那么你就进入test文件夹。<br><strong>.git文件是隐藏文件你需要显示隐藏文件才能看见</strong></p>
<p>进入.git文件编辑.git文件中的config文件修改config文件中的url路径为你的新远程仓库地址路径。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="GitHub无法进入问题"><a href="#GitHub无法进入问题" class="headerlink" title="GitHub无法进入问题"></a>GitHub无法进入问题</h4><blockquote>
<p>参考 <a href="https://blog.csdn.net/cy15625010944/article/details/121633044?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164475083016780274176008%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164475083016780274176008&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-3-121633044.pc_search_result_control_group&utm_term=github%E5%AE%98%E7%BD%91%E8%BF%9B%E4%B8%8D%E5%8E%BB&spm=1018.2226.3001.4187">github等网站访问不稳定的几种改善办法</a></p>
</blockquote>
<p><strong>修改hosts</strong></p>
<blockquote>
<p>Windows 系统：C:\Windows\System32\drivers\etc\hosts<br>Linux 系统：/etc/hosts<br>Mac（苹果电脑）系统：/etc/hosts<br>Android（安卓）系统：/system/etc/hosts<br>iPhone（iOS）系统：/etc/hosts<br>然后将下面这些数据拷贝到自己电脑的hosts文件，再激活生效就可以了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">140.82.112.25                 live.github.com</span><br><span class="line">185.199.108.154               github.githubassets.com</span><br><span class="line">140.82.112.22                 central.github.com</span><br><span class="line">185.199.108.133               desktop.githubusercontent.com</span><br><span class="line">185.199.108.153               assets-cdn.github.com</span><br><span class="line">185.199.108.133               camo.githubusercontent.com</span><br><span class="line">185.199.108.133               github.map.fastly.net</span><br><span class="line">199.232.69.194                github.global.ssl.fastly.net</span><br><span class="line">140.82.112.4                  gist.github.com</span><br><span class="line">185.199.108.153               github.io</span><br><span class="line">140.82.114.4                  github.com</span><br><span class="line">192.0.66.2                    github.blog</span><br><span class="line">140.82.112.6                  api.github.com</span><br><span class="line">185.199.108.133               raw.githubusercontent.com</span><br><span class="line">185.199.108.133               user-images.githubusercontent.com</span><br><span class="line">185.199.108.133               favicons.githubusercontent.com</span><br><span class="line">185.199.108.133               avatars5.githubusercontent.com</span><br><span class="line">185.199.108.133               avatars4.githubusercontent.com</span><br><span class="line">185.199.108.133               avatars3.githubusercontent.com</span><br><span class="line">185.199.108.133               avatars2.githubusercontent.com</span><br><span class="line">185.199.108.133               avatars1.githubusercontent.com</span><br><span class="line">185.199.108.133               avatars0.githubusercontent.com</span><br><span class="line">185.199.108.133               avatars.githubusercontent.com</span><br><span class="line">140.82.112.10                 codeload.github.com</span><br><span class="line">52.217.223.17                 github-cloud.s3.amazonaws.com</span><br><span class="line">52.217.199.41                 github-com.s3.amazonaws.com</span><br><span class="line">52.217.93.164                 github-production-release-asset-2e65be.s3.amazonaws.com</span><br><span class="line">52.217.174.129                github-production-user-asset-6210df.s3.amazonaws.com</span><br><span class="line">52.217.129.153                github-production-repository-file-5c1aeb.s3.amazonaws.com</span><br><span class="line">185.199.108.153               githubstatus.com</span><br><span class="line">64.71.144.202                 github.community</span><br><span class="line">23.100.27.125                 github.dev</span><br><span class="line">185.199.108.133               media.githubusercontent.com</span><br></pre></td></tr></table></figure>
<p>大部分情况下是直接生效，如未生效可尝试下面的办法，刷新 DNS：</p>
<blockquote>
<p>Windows：在 CMD 窗口输入：<code>ipconfig /flushdns</code><br>Linux 命令：<code>sudo nscd restart</code>，如报错则须安装：<code>sudo apt install nscd</code> 或 <code>sudo /etc/init.d/nscd restart</code><br>Mac 命令：<code>sudo killall -HUP mDNSResponder</code></p>
</blockquote>
<p>如果还没有生效的话，可以尝试重启一下电脑，毕竟这步操作可以解决 95 % 的电脑bug。</p>
<p>点评：该方法可以解决改善不稳定的问题，但是有一定的风险性，当然还<strong>有一些自动修改hosts文件的软件，所以如果手动修改hosts也没用的话，建议再参考一下镜像通道。</strong></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Python_Turtle库制作的扫雷</title>
    <url>/2021/08/23/%E5%9F%BA%E4%BA%8EPython-Turtle%E5%BA%93%E5%88%B6%E4%BD%9C%E7%9A%84%E6%89%AB%E9%9B%B7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    经过前几个月的忙碌，假期突然有了时间可以做自己的事，稍微有些不习惯。想起之前答应舍友制作一个扫雷给她玩，顺便打发时间。最终完成板的扫雷基本能够进行游戏，也有部分功能有待完善。下面是项目的介绍。</p>
<span id="more"></span>
<hr>
<h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>游戏构思时主要的分成两大部分：<code>界面组成</code>和<code>游戏运行</code>。</p>
<p><img src="https://z3.ax1x.com/2021/08/24/hiaJDP.png" alt="扫雷 逻辑思路"></p>
<h4 id="界面组成"><a href="#界面组成" class="headerlink" title="界面组成"></a>界面组成</h4><p>游戏界面主要分为<code>游戏进行区</code>和<code>配置/显示区</code></p>
<ul>
<li><p><code>游戏进行区</code>为扫雷游戏部分，界面的元素包括是由方格组成的雷区，以及扫雷过程中出现的旗子、问号、炸弹等。</p>
</li>
<li><p><code>配置/显示区</code>包括有计分（剩余雷数）显示、计时显示、重置（笑脸/哭脸）显示、游戏进行区参数设置等。由于能力和时间有限，计时区和参数区还未设计。</p>
</li>
</ul>
<p><img src="https://z3.ax1x.com/2021/08/24/hia3jI.png" alt="界面组成1"></p>
<p><img src="https://z3.ax1x.com/2021/08/24/hiaGut.png" alt="界面组成2"></p>
<h4 id="游戏运行"><a href="#游戏运行" class="headerlink" title="游戏运行"></a>游戏运行</h4><p>游戏进行部分我主要分为<code>初始化</code>、<code>游戏进行中</code>、<code>游戏结束</code></p>
<ul>
<li><code>初始化</code>包括显示界面的初始化、游戏中相关参数的初始化。参数包括有布置雷数、有雷区域标记、区域是否扫过标记、游戏是否能够进行（游戏是否失败）标记等。为了使第一次不会踩到雷，我采用了点击第一下再开始有雷区域的布置，同时计时开始。</li>
<li><code>游戏进行</code>中，在没有踩到雷的情况下，要计算点击的格子附近是否有雷，如果四周有雷则显示雷数，如果无雷则自动展开无雷区域。自动展开无雷区采用的是<code>BSF（广搜）</code>的方法。</li>
<li><code>游戏结束</code>分为<code>扫雷失败</code>和<code>扫雷成功</code>两种。<ul>
<li><code>扫雷失败</code>即点到雷后，重置游戏部分显示变为哭脸显示，显示区域所有雷，并且踩到雷的格子显示红色。</li>
<li><code>扫雷成功</code>即为成功扫出所有无雷区域，所有有雷区域插上旗子，计时停止，计数归零</li>
</ul>
</li>
</ul>
<hr>
<h2 id="重点难点"><a href="#重点难点" class="headerlink" title="重点难点"></a>重点难点</h2><h4 id="展开无雷区——BFS（广搜）"><a href="#展开无雷区——BFS（广搜）" class="headerlink" title="展开无雷区——BFS（广搜）"></a>展开无雷区——BFS（广搜）</h4><p>关于展开无雷区域，我一开始采用了递归的方法，发现程序运行时一直陷入了死循环（可能是我参数配置有误）。向朋友请教后，采用了广搜的方法。当扫到的格子四周雷数不为0时，则停止搜索。</p>
<p><strong>参考代码</strong><br><a href="https://blog.csdn.net/AivenZhong/article/details/85009225?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162971890516780255297165%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162971890516780255297165&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-85009225.pc_search_result_control_group&amp;utm_term=python%E5%B9%BF%E6%90%9C&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/AivenZhong/article/details/85009225?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162971890516780255297165%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162971890516780255297165&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-85009225.pc_search_result_control_group&amp;utm_term=python%E5%B9%BF%E6%90%9C&amp;spm=1018.2226.3001.4187</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def bfs(start, matrix):</span><br><span class="line">    &quot;&quot;&quot;广搜&quot;&quot;&quot;</span><br><span class="line">    n = len(matrix)</span><br><span class="line">    queue = []</span><br><span class="line">    queue.append(start)</span><br><span class="line">    vis = [[False for _ in range(n)] for _ in range(n)]</span><br><span class="line">    vis[start[0]][start[1]] = True</span><br><span class="line">    dires = [[0, 1], [0, -1], [1, 0], [-1, 0]]</span><br><span class="line">    while queue:</span><br><span class="line">        x, y = queue.pop(0)</span><br><span class="line">        print(matrix[x][y], end=&#x27; &#x27;)</span><br><span class="line">        for dx, dy in dires:</span><br><span class="line">            nx, ny = x + dx, y + dy</span><br><span class="line">            if 0 &lt;= nx &lt; n and 0 &lt;= ny &lt; n and not vis[nx][ny]:</span><br><span class="line">                queue.append([nx, ny])</span><br><span class="line">                vis[nx][ny] = True</span><br><span class="line"></span><br><span class="line">n = 6</span><br><span class="line">matrix = [</span><br><span class="line">    [3, 0, 5, 4, 1, 2],</span><br><span class="line">    [0, 4, 1, 3, 2, 5],</span><br><span class="line">    [3, 1, 5, 2, 4, 0],</span><br><span class="line">    [4, 3, 0, 2, 1, 5],</span><br><span class="line">    [3, 4, 2, 0, 1, 5],</span><br><span class="line">    [1, 5, 3, 4, 2, 0],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">print(&#x27;\n广搜bfs&#x27;)</span><br><span class="line">bfs([0, 0], matrix)</span><br><span class="line"></span><br><span class="line"># 运行结果</span><br><span class="line"># 广搜bfs</span><br><span class="line"># 3 0 0 5 4 3 4 1 1 4 1 3 5 3 3 2 2 2 0 4 1 5 4 2 2 5 0 1 0 3 5 1 4 5 2 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="待解决——计时"><a href="#待解决——计时" class="headerlink" title="待解决——计时"></a>待解决——计时</h2><p>计时部分最开始的时候有做设计，但是由于制作过程中，发现如果代码要中断去执行函数更新。</p>
<p>询问朋友，建议直接读取系统时钟做差值计算得出时间。</p>
<hr>
<h2 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h2><h6 id="gamebase-py"><a href="#gamebase-py" class="headerlink" title="gamebase.py"></a>gamebase.py</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from turtle import *</span><br><span class="line"></span><br><span class="line">#雷区外框大小</span><br><span class="line">def square(x,y,sizex,sizey,color_name):</span><br><span class="line">    up()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    down()</span><br><span class="line">    color(color_name)</span><br><span class="line">    begin_fill()</span><br><span class="line"></span><br><span class="line">    forward(sizex)</span><br><span class="line">    left(90)</span><br><span class="line">    forward(sizey)</span><br><span class="line">    left(90)</span><br><span class="line">    forward(sizex)</span><br><span class="line">    left(90)</span><br><span class="line">    forward(sizey)</span><br><span class="line">    left(90)</span><br><span class="line"></span><br><span class="line">    up()</span><br><span class="line">    goto(0,0)</span><br><span class="line">    down()</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">def box_init(x_num,y_num,z):</span><br><span class="line">    pu()</span><br><span class="line">    color(&quot;black&quot;)</span><br><span class="line">    </span><br><span class="line">    for i in range(0,y_num+1):</span><br><span class="line">        goto((-x_num/2)*z,(i-y_num/2)*z-10)</span><br><span class="line">        pd()</span><br><span class="line">        fd(x_num*z)</span><br><span class="line">        pu()</span><br><span class="line">    lt(90)</span><br><span class="line">    for j in range(0,x_num+1):</span><br><span class="line">        goto((j-x_num/2)*z,(-y_num/2)*z-10)</span><br><span class="line">        pd()</span><br><span class="line">        fd(y_num*z)</span><br><span class="line">        pu()</span><br><span class="line">    setheading(0)</span><br><span class="line"></span><br><span class="line">def drawLine(psize,line,draw):</span><br><span class="line">    pensize(psize)#设置画笔大小</span><br><span class="line">    pu()</span><br><span class="line">    fd(line)</span><br><span class="line">    if draw:</span><br><span class="line">        pd()</span><br><span class="line">    else:</span><br><span class="line">        pu()</span><br><span class="line">    </span><br><span class="line">    fd(3*line+5)#设置数码管长度</span><br><span class="line">    pu()</span><br><span class="line">    fd(line)</span><br><span class="line">    right(90)</span><br><span class="line"></span><br><span class="line">def drawNum(psize,line,num,color_name):</span><br><span class="line">    color(color_name)</span><br><span class="line">    # 第一条线</span><br><span class="line">    if num in [2, 3, 4, 5, 6, 8, 9]:</span><br><span class="line">        drawLine(psize,line,True)</span><br><span class="line">    else:</span><br><span class="line">        drawLine(psize,line,False)</span><br><span class="line"> </span><br><span class="line">    if num in [0, 1, 3, 4, 5, 6, 7, 8, 9]:</span><br><span class="line">        drawLine(psize,line,True)</span><br><span class="line">    else:</span><br><span class="line">        drawLine(psize,line,False)</span><br><span class="line"> </span><br><span class="line">    if num in [0, 2, 3, 5, 6, 8, 9]:</span><br><span class="line">        drawLine(psize,line,True)</span><br><span class="line">    else:</span><br><span class="line">        drawLine(psize,line,False)</span><br><span class="line"> </span><br><span class="line">    if num in [0, 2, 6, 8]:</span><br><span class="line">        drawLine(psize,line,True)</span><br><span class="line">    else:</span><br><span class="line">        drawLine(psize,line,False)</span><br><span class="line"> </span><br><span class="line">    left(90)</span><br><span class="line"> </span><br><span class="line">    if num in [0, 4, 5, 6, 8, 9]:</span><br><span class="line">        drawLine(psize,line,True)</span><br><span class="line">    else:</span><br><span class="line">        drawLine(psize,line,False)</span><br><span class="line"> </span><br><span class="line">    if num in [0, 2, 3, 5, 6, 7, 8, 9]:</span><br><span class="line">        drawLine(psize,line,True)</span><br><span class="line">    else:</span><br><span class="line">        drawLine(psize,line,False)</span><br><span class="line"> </span><br><span class="line">    if num in [0, 1, 2, 3, 4, 7, 8, 9]:</span><br><span class="line">        drawLine(psize,line,True)</span><br><span class="line">    else:</span><br><span class="line">        drawLine(psize,line,False)</span><br><span class="line"> </span><br><span class="line">    pu()</span><br><span class="line">    left(180)</span><br><span class="line">    update()</span><br><span class="line"></span><br><span class="line">#分数</span><br><span class="line">def score_num(psize,line,num,color_name):</span><br><span class="line">    drawNum(psize,line,num[0],color_name)</span><br><span class="line">    pu()</span><br><span class="line">    fd(line*3)</span><br><span class="line">    drawNum(psize,line,num[1],color_name)</span><br><span class="line">    pu()</span><br><span class="line">    fd(line*3)</span><br><span class="line">    drawNum(psize,line,num[2],color_name)</span><br><span class="line">    pu()</span><br><span class="line">    fd(line*3)</span><br><span class="line">    drawNum(psize,line,num[3],color_name)</span><br><span class="line">    </span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line">#时间</span><br><span class="line">def time(psize,line,num,color_name):</span><br><span class="line">    drawNum(psize,line,num[0],color_name)</span><br><span class="line">    pu()</span><br><span class="line">    fd(line*3)</span><br><span class="line">    drawNum(psize,line,num[1],color_name)</span><br><span class="line">    pu()</span><br><span class="line">    fd(line*3)</span><br><span class="line">    drawNum(psize,line,num[2],color_name)</span><br><span class="line">    fd(line*3)</span><br><span class="line">    drawNum(psize,line,num[3],color_name)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line">#写数字</span><br><span class="line">def write_sum(x,y,k):</span><br><span class="line">    pu()</span><br><span class="line">    goto(x+10,y-5)</span><br><span class="line">    pencolor(&quot;black&quot;)</span><br><span class="line">    pd()</span><br><span class="line">    write(k, False, align=&quot;left&quot;,font=(&#x27;arial&#x27;,12,&#x27;normal&#x27;))</span><br><span class="line">    pu()</span><br><span class="line">    setheading(0)</span><br><span class="line"></span><br><span class="line">#两点间距离</span><br><span class="line">def distance(x,y,a,b):</span><br><span class="line">    return ((a-x)**2+(b-y)**2)**0.5</span><br><span class="line"></span><br><span class="line">#画圆弧</span><br><span class="line">def Arc(initial_degree,step,rotate,rangeNum):</span><br><span class="line">    seth(initial_degree)</span><br><span class="line">    for i in range(rangeNum):</span><br><span class="line">        fd(step)</span><br><span class="line">        lt(rotate)</span><br><span class="line"></span><br><span class="line">#笑脸</span><br><span class="line">def smile():</span><br><span class="line">    pensize(1)#设置画笔大小</span><br><span class="line">    fillcolor(&quot;yellow&quot;)</span><br><span class="line">    pencolor(&quot;black&quot;)</span><br><span class="line">    penup()</span><br><span class="line">    goto(0,150)</span><br><span class="line">    pendown()</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(15)</span><br><span class="line">    end_fill()</span><br><span class="line">	#左眼</span><br><span class="line">    penup()</span><br><span class="line">    left(90)</span><br><span class="line">    fd(20)</span><br><span class="line">    left(90)</span><br><span class="line">    fd(7)</span><br><span class="line">    fillcolor(&quot;black&quot;)</span><br><span class="line">    pendown()</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(1)</span><br><span class="line">    end_fill()</span><br><span class="line">	#右眼 </span><br><span class="line">    penup()</span><br><span class="line">    left(180)</span><br><span class="line">    fd(14)</span><br><span class="line">    left(180)</span><br><span class="line">    pendown()</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(1)</span><br><span class="line">    end_fill()</span><br><span class="line">	#嘴巴</span><br><span class="line">    penup()</span><br><span class="line">    fd(14)</span><br><span class="line">    left(90)</span><br><span class="line">    fd(10)</span><br><span class="line">    pendown()</span><br><span class="line">    Arc(-71,0.5,4,38)</span><br><span class="line">    end_fill()</span><br><span class="line">    setheading(0)</span><br><span class="line"></span><br><span class="line">    update()</span><br><span class="line">    </span><br><span class="line">#失败表情</span><br><span class="line">def F_face():</span><br><span class="line">    pensize(1)#设置画笔大小</span><br><span class="line">    fillcolor(&quot;yellow&quot;)</span><br><span class="line">    pencolor(&quot;black&quot;)</span><br><span class="line">    penup()</span><br><span class="line">    goto(0,150)</span><br><span class="line">    pendown()</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(15)</span><br><span class="line">    end_fill()</span><br><span class="line">	#左眼</span><br><span class="line">    penup()</span><br><span class="line">    left(90)</span><br><span class="line">    fd(20)</span><br><span class="line">    left(90)</span><br><span class="line">    fd(7)</span><br><span class="line">    fillcolor(&quot;black&quot;)</span><br><span class="line">    pendown()</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(1)</span><br><span class="line">    end_fill()</span><br><span class="line">	#右眼 </span><br><span class="line">    penup()</span><br><span class="line">    left(180)</span><br><span class="line">    fd(14)</span><br><span class="line">    left(180)</span><br><span class="line">    pendown()</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(1)</span><br><span class="line">    end_fill()</span><br><span class="line">	#嘴巴</span><br><span class="line">    penup()</span><br><span class="line">    fd(14)</span><br><span class="line">    left(90)</span><br><span class="line">    fd(10)</span><br><span class="line">    pendown()</span><br><span class="line">    Arc(-71,0.5,4,20)</span><br><span class="line">    end_fill()</span><br><span class="line">    setheading(0)</span><br><span class="line"></span><br><span class="line">    update()</span><br><span class="line"></span><br><span class="line">#雷区</span><br><span class="line">def BOMB_area(x,y):</span><br><span class="line">    pu()</span><br><span class="line">    color(&quot;black&quot;)</span><br><span class="line">    goto(x,y)</span><br><span class="line">    fd(15)</span><br><span class="line">    lt(90)</span><br><span class="line">    fd(5)</span><br><span class="line">    pd()</span><br><span class="line">    for i in range(0,4):</span><br><span class="line">        fd(10)</span><br><span class="line">        bk(20)</span><br><span class="line">        fd(10)</span><br><span class="line">        lt(45)</span><br><span class="line">    pu()</span><br><span class="line">    setheading(0)</span><br><span class="line">#炸雷</span><br><span class="line">def BOMB(x,y):</span><br><span class="line">    square(x+1,y-9,28,28,&quot;red&quot;)</span><br><span class="line">    BOMB_area(x,y)</span><br><span class="line">def other_BOMB(x,y):</span><br><span class="line">    square(x+1,y-9,28,28,&quot;grey&quot;)</span><br><span class="line">    BOMB_area(x,y)</span><br><span class="line"></span><br><span class="line">#旗子</span><br><span class="line">def flag(x,y):</span><br><span class="line">    pu()</span><br><span class="line">    pencolor(&quot;black&quot;)</span><br><span class="line">    fillcolor(&quot;red&quot;)</span><br><span class="line">    goto(x,y)</span><br><span class="line">    fd(12)</span><br><span class="line">    lt(90)</span><br><span class="line">    bk(5)</span><br><span class="line">    pd()</span><br><span class="line">    fd(20)</span><br><span class="line">    begin_fill()</span><br><span class="line">    for i in range(0,3):</span><br><span class="line">        rt(120)</span><br><span class="line">        fd(10)</span><br><span class="line">    end_fill()</span><br><span class="line">    pu()</span><br><span class="line">    setheading(0)</span><br><span class="line"></span><br><span class="line">#问号</span><br><span class="line">def q_mark(x,y):</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y-5)</span><br><span class="line">    pencolor(&quot;black&quot;)</span><br><span class="line">    pd()</span><br><span class="line">    write(&quot;   ?&quot;, False, align=&quot;left&quot;,font=(&#x27;arial&#x27;,12,&#x27;normal&#x27;))</span><br><span class="line">    pu()</span><br><span class="line">    setheading(0)</span><br></pre></td></tr></table></figure>

<h6 id="saolei-py"><a href="#saolei-py" class="headerlink" title="saolei.py"></a>saolei.py</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from turtle import*</span><br><span class="line">from gamebase import*</span><br><span class="line">from random import randrange</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line">#定义参数</span><br><span class="line">###最多炸弹数</span><br><span class="line">##bomb_max=200</span><br><span class="line">#初始化炸弹数</span><br><span class="line">bomb_init=20</span><br><span class="line">#炸弹初始化大小</span><br><span class="line">bomb=bomb_init</span><br><span class="line"></span><br><span class="line">#初始化雷区地图数组</span><br><span class="line">map_x=0</span><br><span class="line">map_y=0</span><br><span class="line">a=[([0]*10)for i in range(10)]  #标记 没扫过/插旗/未知 0/1/2 初始化0 </span><br><span class="line">b=[([0]*11)for i in range(11)]  #判断雷 有/无 1/0 初始化0</span><br><span class="line">c=[([0]*10)for i in range(10)]  #数雷</span><br><span class="line"></span><br><span class="line">count=0</span><br><span class="line"></span><br><span class="line">game_star=0</span><br><span class="line"></span><br><span class="line">#判断是否可进行游戏</span><br><span class="line">check=0</span><br><span class="line"></span><br><span class="line">###区域最大范围</span><br><span class="line">##areax_max=30</span><br><span class="line">##areay_max=24</span><br><span class="line">#初始化区域范围</span><br><span class="line">areax_init=10</span><br><span class="line">areay_init=10</span><br><span class="line">#格子大小</span><br><span class="line">box=30</span><br><span class="line"></span><br><span class="line">#地图初始化大小</span><br><span class="line">areax_num=areax_init</span><br><span class="line">areay_num=areay_init</span><br><span class="line"></span><br><span class="line">areax=areax_init*box</span><br><span class="line">areay=areay_init*box</span><br><span class="line"></span><br><span class="line">#计时初始化</span><br><span class="line">time_int=0</span><br><span class="line">time_cnt=time_int</span><br><span class="line">#数字</span><br><span class="line">NUM=[bomb//1000,(bomb//100)%10,(bomb//10)%10,bomb%10]</span><br><span class="line"></span><br><span class="line">#计时区</span><br><span class="line">TIME=[time_cnt//1000,time_cnt//100%10,time_cnt//10%10,time_cnt%10]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#地图数组坐标</span><br><span class="line">def find_map(x,y):</span><br><span class="line">    global map_x,map_y</span><br><span class="line">    map_x=int(x//box)+5</span><br><span class="line">    map_y=int((y+10)//box)+5</span><br><span class="line"></span><br><span class="line">#计分区</span><br><span class="line">def update_score():</span><br><span class="line">    square(-160,150,100,40,&quot;white&quot;)</span><br><span class="line">    </span><br><span class="line">    #数字</span><br><span class="line">    NUM=[bomb//1000,(bomb//100)%10,(bomb//10)%10,bomb%10]</span><br><span class="line">    pu()</span><br><span class="line">    goto(-(areax/2-10),areax/2+15)</span><br><span class="line">    score_num(2,1,NUM,&quot;orange&quot;)</span><br><span class="line"></span><br><span class="line">#开始游戏</span><br><span class="line">def game_init():</span><br><span class="line">    global a,b,c,count</span><br><span class="line">    clear()</span><br><span class="line">    hideturtle()</span><br><span class="line">    tracer(False)</span><br><span class="line">    a=[([0]*10)for i in range(10)]</span><br><span class="line">    b=[([0]*11)for i in range(11)]</span><br><span class="line">    c=[([0]*10)for i in range(10)]</span><br><span class="line">    count=0</span><br><span class="line">    square(-areax/2-5,-areay/2-5-10,areax+10,areay+10,&quot;grey&quot;)            #画边框</span><br><span class="line">    box_init(10,10,box)                     #小格子</span><br><span class="line">    smile()</span><br><span class="line">    update_score()</span><br><span class="line"></span><br><span class="line">#生成地雷</span><br><span class="line">def new_game(x,y):</span><br><span class="line">    global map_x,map_y,b</span><br><span class="line">    k=bomb</span><br><span class="line">    find_map(x,y)</span><br><span class="line">    while k&gt;0:</span><br><span class="line">        i=randrange(0,10)</span><br><span class="line">        j=randrange(0,10)</span><br><span class="line">        if i!=map_x and j!=map_y:</span><br><span class="line">            if b[i][j]==0:</span><br><span class="line">                b[i][j]=1</span><br><span class="line">                k=k-1</span><br><span class="line"></span><br><span class="line">#统计雷</span><br><span class="line">def Statistics(x,y):</span><br><span class="line">    k = b[x-1][y+1]+b[x][y+1]+b[x+1][y+1]+b[x-1][y]+b[x][y]+b[x+1][y]+b[x-1][y-1]+b[x][y-1]+b[x+1][y-1]</span><br><span class="line">    return k</span><br><span class="line"></span><br><span class="line">#自动展开无雷区</span><br><span class="line">def auto_expand(x,y):</span><br><span class="line">    global b</span><br><span class="line">    bfs([x,y], b)</span><br><span class="line">                </span><br><span class="line">#广搜</span><br><span class="line">def bfs(start, matrix):</span><br><span class="line">    global count,c</span><br><span class="line">    n = len(matrix)</span><br><span class="line">    queue = []</span><br><span class="line">    queue.append(start)</span><br><span class="line">    vis = [[False for _ in range(n)] for _ in range(n)]</span><br><span class="line">    vis[start[0]][start[1]] = True</span><br><span class="line">    dires = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]</span><br><span class="line">    while queue:</span><br><span class="line">        x, y = queue.pop(0)</span><br><span class="line">        k=Statistics(x,y)</span><br><span class="line">        square((x-5)*box+2,(y-5)*box-9,27,27,&quot;white&quot;)</span><br><span class="line">        if c[x][y]==0:</span><br><span class="line">            c[x][y]=1</span><br><span class="line">            count=count+1</span><br><span class="line">        if k==0:</span><br><span class="line">            for dx, dy in dires:</span><br><span class="line">                nx, ny = x + dx, y + dy</span><br><span class="line">                if 0 &lt;= nx &lt; n-1 and 0 &lt;= ny &lt; n-1 and not vis[nx][ny]:</span><br><span class="line">                    vis[nx][ny] = True</span><br><span class="line">                    l=Statistics(nx,nx)</span><br><span class="line">                    if matrix[nx][ny]==0:</span><br><span class="line">                        queue.append([nx, ny])</span><br><span class="line">                    else:</span><br><span class="line">                        if c[nx][ny]==0:</span><br><span class="line">                            c[nx][ny]=1</span><br><span class="line">                            count=count+1</span><br><span class="line">                        square((nx-5)*box+2,(ny-5)*box-9,27,27,&quot;white&quot;)</span><br><span class="line">                        write_sum((nx-5)*box,(nx-5)*box,l)</span><br><span class="line">        else:</span><br><span class="line">            write_sum((x-5)*box+2,(y-5)*box,k)</span><br><span class="line"></span><br><span class="line">##左键点击屏幕</span><br><span class="line">def tap(x,y):</span><br><span class="line">    global bomb,NUM,check,game_star,map_x,map_y,a,b,c,count</span><br><span class="line">    find_map(x,y)</span><br><span class="line">    </span><br><span class="line">    if distance(x,y,0,165)&lt;(15):</span><br><span class="line">        bomb=bomb_init</span><br><span class="line">        smile()</span><br><span class="line">        game_init()</span><br><span class="line">        check=0</span><br><span class="line">        update_score()</span><br><span class="line">        game_star=0</span><br><span class="line">        return</span><br><span class="line">        </span><br><span class="line">    if game_star==0:</span><br><span class="line">        new_game(x,y)</span><br><span class="line">        game_star=1</span><br><span class="line"></span><br><span class="line">    if -areax/2&lt;=x&lt;=areax/2 and -areay/2-10&lt;=y&lt;=areay/2-10:</span><br><span class="line">        if check==0:</span><br><span class="line">            auto_expand(map_x,map_y)</span><br><span class="line">            if b[map_x][map_y]==1:</span><br><span class="line">                F_face()</span><br><span class="line">                for i in range(0,10):</span><br><span class="line">                    for j in range(0,10):</span><br><span class="line">                        if b[i][j]==1:</span><br><span class="line">                            other_BOMB((i-5)*box,(j-5)*box)</span><br><span class="line">                BOMB((map_x-5)*box,(map_y-5)*box)</span><br><span class="line">                check=1</span><br><span class="line">                update_score()</span><br><span class="line">                return</span><br><span class="line">            if count==80:</span><br><span class="line">                bomb=0</span><br><span class="line">                for i in range(0,10):</span><br><span class="line">                    for j in range(0,10):</span><br><span class="line">                        if b[i][j]==1:</span><br><span class="line">                            flag((i-5)*box,(j-5)*box)</span><br><span class="line">                check=1</span><br><span class="line">                update_score()</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">##右键</span><br><span class="line">def find(x,y):</span><br><span class="line">    global bomb,map_x,map_y,a,c,check</span><br><span class="line"></span><br><span class="line">    if x&lt;=areax/2 and x&gt;=-areax/2 and y&gt;=-areay/2-10 and y&lt;=areay/2-10 and check==0:</span><br><span class="line">        find_map(x,y)</span><br><span class="line">        if c[map_x][map_y]==0:</span><br><span class="line">            if a[map_x][map_y]==0:</span><br><span class="line">                a[map_x][map_y]=1</span><br><span class="line">                flag(map_x*box-areax/2,map_y*box-areay/2)</span><br><span class="line">                bomb-=1</span><br><span class="line">                update_score()</span><br><span class="line">                return</span><br><span class="line">            if a[map_x][map_y]==1:</span><br><span class="line">                square(map_x*box-areax/2+2,map_y*box-areay/2-9,27,27,&quot;grey&quot;)</span><br><span class="line">                a[map_x][map_y]=2</span><br><span class="line">                q_mark(map_x*box-areax/2,map_y*box-areay/2)</span><br><span class="line">                bomb+=1</span><br><span class="line">                update_score()</span><br><span class="line">                return</span><br><span class="line">            if a[map_x][map_y]==2:</span><br><span class="line">                square(map_x*box-areax/2+2,map_y*box-areay/2-9,27,27,&quot;grey&quot;)</span><br><span class="line">                a[map_x][map_y]=0</span><br><span class="line">                return</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">#开始</span><br><span class="line">setup(areax+50,areay+100,0,0)</span><br><span class="line">hideturtle()</span><br><span class="line">tracer(False)</span><br><span class="line"></span><br><span class="line">game_init()</span><br><span class="line"></span><br><span class="line">listen()</span><br><span class="line">onscreenclick(tap)				#左击</span><br><span class="line">onscreenclick(find, btn = 3) 	#右击</span><br><span class="line">done()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>​    这次做的扫雷不算难，因为之前有用Python做过其他小游戏，相对来说还是比较好实现的。完成小游戏后确实学习了不少东西，包括一些python常用的函数，BFS算法等。虽然做的比较简陋，但总体来说还算不错（暂时还没发现bug呢）。<br>​    关于相关的改进，（虽然自己比较懒以后可能也不会去完善了）有一下几点。</p>
<ul>
<li>加上计时部分。（最近如果有时间就做）</li>
<li>实现难度选择和自定义功能。</li>
<li>实现对记录成绩。</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub基础操作</title>
    <url>/2021/08/17/GitHub%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<blockquote>
<p>资料参考<a href="https://www.bilibili.com/video/BV1yo4y1d7UK">https://www.bilibili.com/video/BV1yo4y1d7UK</a></p>
</blockquote>
<span id="more"></span>

<h4 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h4><ul>
<li>username</li>
<li>emailaddress <code>用于验证用户</code></li>
<li>password</li>
</ul>
<hr>
<h4 id="查找仓库（Repository）"><a href="#查找仓库（Repository）" class="headerlink" title="查找仓库（Repository）"></a>查找仓库（Repository）</h4><h5 id="仓库路径"><a href="#仓库路径" class="headerlink" title="仓库路径"></a>仓库路径</h5><p><a href="https://github.com/hamster-ren/text">https://github.com/hamster-ren/text</a><br>域名+仓库的主人+仓库名字（+.git)</p>
<h5 id="GitHub-explore"><a href="#GitHub-explore" class="headerlink" title="GitHub explore"></a>GitHub explore</h5><p>根据浏览习惯生成仓库列表<br>每天刷新</p>
<hr>
<h4 id="仓库管理"><a href="#仓库管理" class="headerlink" title="仓库管理"></a>仓库管理</h4><h5 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h5><ul>
<li><p>点击 <code>+</code>下方<code>New repositroy</code><br><img src="https://z3.ax1x.com/2021/08/24/hiUR1A.png" alt="New repositroy"></p>
</li>
<li><p>Owner / Repository name (必填)</p>
</li>
<li><p>Description 仓库简介</p>
</li>
<li><p>仓库可见性</p>
</li>
<li><p>仓库初始化时添加的文件</p>
<ul>
<li><p>Add a README file</p>
</li>
<li><p>Add .gitignore<br>  一般来说每个Git项目中都需要一个“.gitignore”文件，这个文件的作用就是告诉Git哪些文件不需要添加到版本管理中。<a href="https://www.cnblogs.com/qianduanjingying/p/6184613.html">https://www.cnblogs.com/qianduanjingying/p/6184613.html</a></p>
</li>
<li><p>Choose a license<br>  开源许可证<br>  一般选用MIT</p>
<p><img src="https://z3.ax1x.com/2021/08/24/hiUfXt.png" alt="初始化设置"></p>
</li>
</ul>
</li>
<li><p><code>Code</code>下<code>Download ZIP</code>下载文件</p>
<p><img src="https://z3.ax1x.com/2021/08/24/hiUW6I.png" alt="Download ZIP"></p>
</li>
</ul>
<h5 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h5><ul>
<li><p><code>Add file</code>添加文件</p>
<ul>
<li><code>Create new file</code>直接在仓库添加文件</li>
<li><code>Upload files</code>从本地文件上传文件</li>
</ul>
<p><img src="https://z3.ax1x.com/2021/08/24/hiU2pd.png" alt="add file"></p>
</li>
</ul>
<h5 id="提交-Issue"><a href="#提交-Issue" class="headerlink" title="提交 Issue"></a>提交 Issue</h5><ul>
<li><p>在仓库文件中点击<code>Issue</code>菜单</p>
<p><img src="https://z3.ax1x.com/2021/08/24/hiU50f.png" alt="Issue"></p>
</li>
<li><p>点击<code>New issue</code></p>
</li>
<li><p>标题+正文</p>
<p><img src="https://z3.ax1x.com/2021/08/24/hiUTAS.png" alt="New issue"></p>
</li>
<li><p>如果是仓库的所有者，可以把问题归属到自己名下</p>
<p><img src="https://z3.ax1x.com/2021/08/24/hiUI78.png" alt="user"></p>
</li>
<li><p>问题解决后可以关闭<code>issue</code></p>
<ul>
<li><code>close with comment</code></li>
<li>关闭后不能再打开Issue</li>
</ul>
</li>
</ul>
<h5 id="提交-接收-Pull-requests"><a href="#提交-接收-Pull-requests" class="headerlink" title="提交/接收 Pull requests"></a>提交/接收 Pull requests</h5><ul>
<li>进入文件进行编辑</li>
<li>提交后会自动生成<code>Pull requests</code></li>
<li>（一些操作跟提交<code>Issue</code>一样，可参考）</li>
</ul>
<blockquote>
<p>That`s all</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>一些新的规划——记录</title>
    <url>/2021/08/15/%E4%B8%80%E4%BA%9B%E6%96%B0%E7%9A%84%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>现在是2021年8月15日，距离假期结束还有半个月，而我的人生也将在半个月后迈向新的一岁。从大学开始，一切新的事物都向我扑面而来，我还没有做好迎接的准备。而现在，大学生活已经过了两年了，虽然我似乎没干成一件自己称心如意的事，甚至生活学习都变得有些难以应付。但所幸的是我似乎找到了点自己想做的事。却忽然想起，或许两年毕业后，就可能没有时间给自己随心所欲地玩了。我想要趁现在还有点时间，多学些东西。</p>
</blockquote>
<span id="more"></span>

<hr>
<h4 id="一些任务"><a href="#一些任务" class="headerlink" title="一些任务"></a>一些任务</h4><ul>
<li>21赛季完成eplan的教程</li>
<li>老板的飞控板子</li>
<li>看完卓祺的书（<em>至少大三开学前看完三体</em>）</li>
<li>多看书（<em>把手头上的书看完</em>）</li>
<li>把之前还没做出来的智能小车完成</li>
<li>六级500分</li>
<li>想要设计出一个无人机</li>
<li>超焱的无线充电</li>
</ul>
<hr>
<h4 id="学习清单"><a href="#学习清单" class="headerlink" title="学习清单"></a>学习清单</h4><ul>
<li>数电模电（<em>大三</em>）</li>
<li>智能计算系统（<em>大三</em>）</li>
<li>嵌入式设计</li>
<li>python爬虫</li>
<li>机器学习</li>
<li>Android软件开发</li>
</ul>
<hr>
<blockquote>
<p>以后想到再补充 : &gt;</p>
</blockquote>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>贴片电阻规格资料</title>
    <url>/2021/01/27/%E8%B4%B4%E7%89%87%E7%94%B5%E9%98%BB%E8%A7%84%E6%A0%BC%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote>
<p>我们常说的贴片电阻 (SMD Resistor)叫”片式固定电阻器”(Chip Fixed Resistor)，又叫”矩形片状电阻”(Rectangular Chip Resistors)，是由ROHM公司发明并最早推出市场的。特点是<strong>耐潮湿，耐高温，可靠度高，外观尺寸均匀，精确且温度系数与阻值公差小</strong>。 </p>
</blockquote>
<span id="more"></span>


<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p>按<strong>生产工艺</strong>分<strong>厚膜(Thick Film Chip Resistors)</strong> 、 <strong>薄膜(Thin Film Chip Resistors)</strong> 两种。</p>
<p><strong>厚膜</strong>是采用丝网印刷将电阻性材料淀积在绝缘基体(例如玻璃或氧化铝陶瓷)上，然后烧结形成的。我们通常所见的多为厚膜片式电阻，精度范围±0.5% ~ 10%，温度系数:±50PPM/℃ ~ ±400PPM/℃。 </p>
<p><strong>薄膜</strong>是在真空中采用蒸发和溅射等工艺将电阻性材料淀积在绝缘基体工艺(真空镀膜技术)制成，特点是低温度系数(±5PPM/℃)，高精度(±0.01%～±1%)。 </p>
<h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p><strong>0201，0402，0603，0805，1206，1210，1812，2010，2512。</strong></p>
<p>其常规系列的精度为5%，1%。阻值范围从0.1欧姆到20M欧姆。标准阻值有E24，E96系列。</p>
<p>功率有1/20W、1/16W、1/8W、1/10W、1/4W、1/2W、1W。 </p>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul>
<li>体积小，重量轻 </li>
<li>适合波峰焊和回流焊 </li>
<li>机械强度高，高频特性优越 </li>
<li>常用规格价格比传统的引线电阻还便宜 </li>
<li>生产成本低，配合自动贴片机，适合现代电子产品规模化生产</li>
</ul>
<h5 id="使用状况"><a href="#使用状况" class="headerlink" title="使用状况"></a>使用状况</h5><p>由于价格便宜，生产方便，能大面积减少PCB面积，减少产品外观尺寸，现在已取代绝大部分传统引线电阻。除一些小厂或不得不使用引线电阻的设计，各种电器上几乎都在使用。</p>
<p>目前绝大部分电子产品，以0603、0805器件为主；以手机，PDA为代表的高密度电子产品多使用0201、0402的器件；一些要求稳定和安全的电子产品，如医疗器械、汽车行驶记录仪、税控机则多采用1206、1210等尺寸偏大的电阻。 </p>
<hr>
<h2 id="贴片电阻基本结构"><a href="#贴片电阻基本结构" class="headerlink" title="贴片电阻基本结构"></a>贴片电阻基本结构</h2><p><img src="https://s3.ax1x.com/2021/01/27/sx6gRx.png" alt="贴片电阻基本结构"></p>
<hr>
<h2 id="贴片电阻分类"><a href="#贴片电阻分类" class="headerlink" title="贴片电阻分类"></a>贴片电阻分类</h2><h5 id="贴片电阻分为以下几大类："><a href="#贴片电阻分为以下几大类：" class="headerlink" title="贴片电阻分为以下几大类："></a>贴片电阻分为以下几大类：</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">参考国巨分类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">常规系列厚膜贴片电阻<br>General purpose</td>
<td align="center">General purpose, 0201 - 0805; <br>General purpose, 1206 - 2512</td>
</tr>
<tr>
<td align="center">高精度高稳定性贴片电阻<br>High precision - high stability</td>
<td align="center">High precision - high stability, 0201 - 0603; <br>High precision - high stability, 0805 - 1210; <br>High precision - high stability, 2010 - 2512</td>
</tr>
<tr>
<td align="center">常规系列薄膜贴片电阻<br>General purpose thin film</td>
<td align="center">General purpose thin film, 0201-2512</td>
</tr>
<tr>
<td align="center">低阻值贴片电阻<br>Low ohmic</td>
<td align="center">Low ohmic, 0402 - 1206; Low ohmic, 2010 - 2512</td>
</tr>
<tr>
<td align="center">贴片电阻阵列<br>Arrays</td>
<td align="center">Arrays, convex and concave</td>
</tr>
<tr>
<td align="center">贴片电流传感器<br>SMD current sensors</td>
<td align="center">Current Sensors - Low TCR</td>
</tr>
<tr>
<td align="center">贴片网络电阻器<br>Network</td>
<td align="center">Network, T-type and L-type</td>
</tr>
</tbody></table>
<h5 id="贴片电阻规格、封装、尺寸"><a href="#贴片电阻规格、封装、尺寸" class="headerlink" title="贴片电阻规格、封装、尺寸"></a>贴片电阻规格、封装、尺寸</h5><p><img src="https://s3.ax1x.com/2021/01/27/sxWejx.png" alt="尺寸"></p>
<p>贴片电阻常见封装有9种，用两种尺寸代码来表示。一种尺寸代码是由4位数字表示的EIA(美国电子工业协会)代码，前两位与后两位分别表示电阻的长与宽，以英寸为单位。我们常说的0603封装就是指英制代码。另一种是米制代码，也由4位数字表示，其单位为毫米。下表列出贴片电阻封装英制和公制的关系及详细的尺寸： </p>
<p><img src="https://s3.ax1x.com/2021/01/27/sxWNKP.png" alt="贴片尺寸"></p>
<br>

<table>
<thead>
<tr>
<th align="center">英制<br>(inch)</th>
<th align="center">公制<br>(mm)</th>
<th align="center">长(L)<br>(mm)</th>
<th align="center">宽(W)<br>(mm)</th>
<th align="center">高(t)<br>(mm)</th>
<th align="center">a<br>(mm)</th>
<th align="center">b<br>(mm)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0201</td>
<td align="center">0603</td>
<td align="center">0.60±0.05</td>
<td align="center">0.30±0.05</td>
<td align="center">0.23±0.05</td>
<td align="center">0.10±0.05</td>
<td align="center">0.15±0.05</td>
</tr>
<tr>
<td align="center">0402</td>
<td align="center">1005</td>
<td align="center">1.00±0.10</td>
<td align="center">0.50±0.10</td>
<td align="center">0.30±0.10</td>
<td align="center">0.20±0.10</td>
<td align="center">0.25±0.10</td>
</tr>
<tr>
<td align="center">0603</td>
<td align="center">1608</td>
<td align="center">1.60±0.15</td>
<td align="center">0.80±0.15</td>
<td align="center">0.40±0.10</td>
<td align="center">0.30±0.20</td>
<td align="center">0.30±0.20</td>
</tr>
<tr>
<td align="center">0805</td>
<td align="center">2012</td>
<td align="center">2.00±0.20</td>
<td align="center">1.25±0.15</td>
<td align="center">0.50±0.10</td>
<td align="center">0.40±0.20</td>
<td align="center">0.40±0.20</td>
</tr>
<tr>
<td align="center">1206</td>
<td align="center">3216</td>
<td align="center">3.20±0.20</td>
<td align="center">1.60±0.15</td>
<td align="center">0.55±0.10</td>
<td align="center">0.50±0.20</td>
<td align="center">0.50±0.20</td>
</tr>
<tr>
<td align="center">1210</td>
<td align="center">3225</td>
<td align="center">3.20±0.20</td>
<td align="center">2.50±0.20</td>
<td align="center">0.55±0.10</td>
<td align="center">0.50±0.20</td>
<td align="center">0.50±0.20</td>
</tr>
<tr>
<td align="center">1812</td>
<td align="center">4832</td>
<td align="center">4.50±0.20</td>
<td align="center">3.20±0.20</td>
<td align="center">0.55±0.10</td>
<td align="center">0.50±0.20</td>
<td align="center">0.50±0.20</td>
</tr>
<tr>
<td align="center">2010</td>
<td align="center">5025</td>
<td align="center">5.00±0.20</td>
<td align="center">2.50±0.20</td>
<td align="center">0.55±0.10</td>
<td align="center">0.60±0.20</td>
<td align="center">0.60±0.20</td>
</tr>
<tr>
<td align="center">2512</td>
<td align="center">6432</td>
<td align="center">6.40±0.20</td>
<td align="center">3.20±0.20</td>
<td align="center">0.55±0.10</td>
<td align="center">0.60±0.20</td>
<td align="center">0.60±0.20</td>
</tr>
</tbody></table>
<blockquote>
<p>Note：我们俗称的封装是指英制。</p>
</blockquote>
<h5 id="贴片电阻额定功率及工作电压"><a href="#贴片电阻额定功率及工作电压" class="headerlink" title="贴片电阻额定功率及工作电压"></a>贴片电阻额定功率及工作电压</h5><p>贴片电阻的功率是指通过电流时由于焦耳热电阻产生的功率。<br>可根据焦耳定律算出：</p>
<p>P=I^2*R</p>
<p><strong>额定功率：</strong> 是指在某个温度下最大允许使用的功率，通常指环境温度为70°C时的额定功率。 </p>
<p><strong>额定电压：</strong>可以根据以下公式求出额定电压。 </p>
<p>额定电压(V)＝√(额定功率(W)× 标称阻值(Ω))</p>
<p><strong>最高工作电压：</strong>允许加载在贴片电阻两端的最高电压。 </p>
<p><strong>贴片电阻的封装与功率、电压关系如下表：</strong></p>
<table>
<thead>
<tr>
<th align="center">英制<br>(inch)</th>
<th align="center">公制<br>(mm)</th>
<th align="center">额定功率(W) 70°C</th>
<th align="center">最高工作电压<br>(V)</th>
<th align="center">工作温度(°C)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">01005</td>
<td align="center">0402</td>
<td align="center">1/32</td>
<td align="center">15</td>
<td align="center">-55 ~ +125</td>
</tr>
<tr>
<td align="center">0201</td>
<td align="center">0603</td>
<td align="center">1/20</td>
<td align="center">25</td>
<td align="center">-55 ~ +125</td>
</tr>
<tr>
<td align="center">0402</td>
<td align="center">1005</td>
<td align="center">1/16</td>
<td align="center">50</td>
<td align="center">-55 ~ +155</td>
</tr>
<tr>
<td align="center">0603</td>
<td align="center">1608</td>
<td align="center">1/10</td>
<td align="center">50</td>
<td align="center">-55 ~ +155</td>
</tr>
<tr>
<td align="center">0805</td>
<td align="center">2012</td>
<td align="center">1/8</td>
<td align="center">150</td>
<td align="center">-55 ~ +155</td>
</tr>
<tr>
<td align="center">1206</td>
<td align="center">3216</td>
<td align="center">1/4</td>
<td align="center">200</td>
<td align="center">-55 ~ +155</td>
</tr>
<tr>
<td align="center">1210</td>
<td align="center">3225</td>
<td align="center">1/4</td>
<td align="center">200</td>
<td align="center">-55 ~ +125</td>
</tr>
<tr>
<td align="center">2010</td>
<td align="center">5025</td>
<td align="center">1/2</td>
<td align="center">200</td>
<td align="center">-55 ~ +125</td>
</tr>
<tr>
<td align="center">2512</td>
<td align="center">6432</td>
<td align="center">1</td>
<td align="center">200</td>
<td align="center">-55 ~ +125</td>
</tr>
</tbody></table>
<p><img src="http://file.elecfans.com/web1/M00/45/4E/o4YBAFpoNiOACoKXAAP3Ur0Vi1E412.png" alt="功率及环境温度降额曲线图"></p>
<h5 id="贴片电阻标识"><a href="#贴片电阻标识" class="headerlink" title="贴片电阻标识"></a>贴片电阻标识</h5><p>贴片电阻上面的印字绝大部分标识其阻值大小。各个厂家的印字规则虽然不完全相同，但绝大部分遵照一定规则。 </p>
<p>常见的印字标注方法有“常规3位数标注法”、 “常规4位数标注法”、“3位数乘数代码标注法、 “R表示小数点位置”、“m表示小数点位置 ”。 </p>
<p>0201,0402由于面积太小，通常上面都不印字。<br>0603，0805，1206，1210，1812，2010，2512上面印有3位数或者4位数。</p>
]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建笔记</title>
    <url>/2021/01/27/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>博客搭建笔记 : )</p>
<span id="more"></span>

<hr>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><a href="https://nodejs.org/en/">Nodejs</a><br><a href="https://gitforwindows.org/">Git Bash</a><br>打开 <strong>Git Bash</strong> 输入 <strong>node -v</strong> 和 <strong>npm -v</strong> 检验是否安装成功。</p>
<h4 id="启动CMD，输入以下指令"><a href="#启动CMD，输入以下指令" class="headerlink" title="启动CMD，输入以下指令"></a>启动CMD，输入以下指令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix “C:\博客搭建\Global”</span><br><span class="line">npm config <span class="built_in">set</span> cacha “C:\博客搭建\Global”</span><br></pre></td></tr></table></figure>
<p><strong>记住路径，配置变量的时候会用到</strong></p>
<h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>打开 <strong>Git Bash</strong> 输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
<p>如果Hexo无法使用，需要配置环境变量</p>
<blockquote>
<p>注意hexo版本与node.js的版本要相对应，否则运行hexo服务时会出现警告（但不影响使用）。<br>版本参考<a href="https://hexo.io/docs/">官网</a></p>
</blockquote>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>右击“此电脑”——“属性”——“高级系统设置”——“环境变量”——pc的用户变量——选中path——“编辑”——“新建”——输入“C:\博客搭建\Global”——“确定”<br><img src="https://s3.ax1x.com/2021/01/27/sxSLGR.png" alt="配置路径图一"><br><img src="https://s3.ax1x.com/2021/01/27/sxpkRI.png" alt="配置路径图二"></p>
<p>在<strong>Git Bash</strong> 输入 <strong>hexo -v</strong> 验证</p>
<hr>
<h2 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h2><h4 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h4><p>“C:\博客搭建”创建文件夹，命名为“Blog”<br>进入“Blog”——搜索栏输入cmd<br>进入cmd<br>输入 hexo init<br>输入 hexo s<br><img src="https://s3.ax1x.com/2021/01/27/sxp2wD.png" alt="初始化博客"><br>浏览器输入地址：<u><a href="http://localhost:4000/">http://localhost:4000</a></u><br>初始化博客成功</p>
<h4 id="配置博客-1"><a href="#配置博客-1" class="headerlink" title="配置博客"></a>配置博客</h4><p>打开Blog文件夹——用 Sublime Text 打开“_config.yml”<br><img src="https://s3.ax1x.com/2021/01/27/sxCcIe.png" alt="配置博客1"></p>
<p>修改信息 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title:                                    <span class="comment">#博客名字</span></span><br><span class="line">subtitle: <span class="string">&#x27;good things take time :)&#x27;</span>      <span class="comment">#博客副标题</span></span><br><span class="line">description: <span class="string">&#x27;&#x27;</span>                           <span class="comment">#关于博客的描述</span></span><br><span class="line">keywords:</span><br><span class="line">author: Ren                               <span class="comment">#博客作者</span></span><br><span class="line">language: zh_CN                           <span class="comment">#博客语言</span></span><br><span class="line">timezone: <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br></pre></td></tr></table></figure>

<h6 id="Hexo基本命令"><a href="#Hexo基本命令" class="headerlink" title="Hexo基本命令"></a>Hexo基本命令</h6><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Hexo init</td>
<td align="center">初始化博客</td>
</tr>
<tr>
<td align="center">Hexo s</td>
<td align="center">运行博客</td>
</tr>
<tr>
<td align="center">Hexo n title</td>
<td align="center">创建一篇新的文章，文章标题是title</td>
</tr>
<tr>
<td align="center">Hexo c</td>
<td align="center">清理文件</td>
</tr>
<tr>
<td align="center">Hexo g</td>
<td align="center">生成静态文件</td>
</tr>
<tr>
<td align="center">Hexo d</td>
<td align="center">部署博客（需要插件）</td>
</tr>
</tbody></table>
<h4 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h4><p>CMD输入 <strong>Hexo n title</strong> 创建一篇新的文章，文章标题是title<br><img src="https://s3.ax1x.com/2021/01/27/sxP9dU.png" alt="写文章"><br>打开文件进行编辑<br>文章的编辑方式使用<a href="https://www.runoob.com/markdown/md-block.html"><strong>markdown</strong></a><br>文章保存后在 <strong>cmd</strong> 输入 <strong>hexo s</strong><br>打开连接可以看到新文章</p>
<h4 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h4><p><a href="https://hexo.io/themes/">themes|hexo</a><br>一般会有安装教程文章，详细阅读<br>在Blog文件——“_config.yml”里，找到theme，修改为已下载的主题的名字<br><img src="https://s3.ax1x.com/2021/01/27/sxPGQI.png" alt="配置主题"></p>
<p><strong>此处需要安装插件使博客能够运行。</strong><br>Cmd运行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus</span><br></pre></td></tr></table></figure>
<p>安装插件。</p>
<blockquote>
<p>为方便以后升级方便，不建议对主题文件进行修改。推荐把主题的配置文件“_config.yml”复制到hexo工作目录下的source/_data/ayer.yml，如果目录不存在就创建一个。</p>
</blockquote>
<h4 id="更换图片"><a href="#更换图片" class="headerlink" title="更换图片"></a>更换图片</h4><p>使用网站 <strong><a href="https://imgchr.com/">路过图床</a></strong> 上传图片<br>使用图片UPL链接<br><img src="https://s3.ax1x.com/2021/01/27/sxFaGQ.png" alt="路过图床"> </p>
<h4 id="创建分类页、标签页、友链页"><a href="#创建分类页、标签页、友链页" class="headerlink" title="创建分类页、标签页、友链页"></a>创建分类页、标签页、友链页</h4><p>e.g.<br>分类页<br>前往hexo根目录<br>输入 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>修改文件为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Title: 我的分类页</span><br><span class="line">Data: *******</span><br><span class="line">Type: <span class="string">&quot;catergories&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="友链添加"><a href="#友链添加" class="headerlink" title="友链添加"></a>友链添加</h4><p>在hexo博客目录中的source/_data，创建文件link.ylm<br>编辑</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Class_name:</span><br><span class="line">Class_desc:</span><br><span class="line">Link_list:</span><br><span class="line">	Name:				<span class="comment">#名字</span></span><br><span class="line">	Link:				<span class="comment">#网址</span></span><br><span class="line">	Avatar:				<span class="comment">#头像</span></span><br><span class="line">	Descry:				<span class="comment">#描述</span></span><br></pre></td></tr></table></figure>

<h4 id="关于文章置顶"><a href="#关于文章置顶" class="headerlink" title="关于文章置顶"></a>关于文章置顶</h4><p><strong>安装插件</strong><br>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top –-save</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="部署云端"><a href="#部署云端" class="headerlink" title="部署云端"></a>部署云端</h2><p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git –save</span><br></pre></td></tr></table></figure>
<p>使用<strong>github</strong>部署云端<br>在GitHub中建立一个仓库，仓库名字必须是 <strong>xxx.github.io</strong> , xxx是GitHub名字<br>然后打开博客配置文件_config.yml<br>找到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Deploy:</span><br><span class="line">	Type: git</span><br><span class="line">	Repo:&lt;仓库地址&gt;</span><br><span class="line">	Branch: master </span><br></pre></td></tr></table></figure>
<p>cmd运行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hexo clean </span><br><span class="line">hexo g</span><br><span class="line">Hexo d</span><br></pre></td></tr></table></figure>
<p>如果报错<br>根据提示运行命令</p>
<blockquote>
<p>创建博客完成</p>
</blockquote>
<hr>
<h2 id="博客备份与恢复"><a href="#博客备份与恢复" class="headerlink" title="博客备份与恢复"></a>博客备份与恢复</h2><blockquote>
<p>由于电脑总是会无可避免的进行重装或者会出现硬件损坏等问题，这时候需要将博客本地文件进行备份和恢复。</p>
</blockquote>
<h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><ul>
<li>备份整个博客文件到GitHub等代码托管平台</li>
<li>U盘等存储硬件备份</li>
</ul>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><ul>
<li>确保本地Hexo博客基础环境已经搭好，电脑已经安装git，node.js，hexo，npm等。（注意：新版的NodeJS已经集成了npm不需要单独下载）</li>
<li>将备份文件重新下载到电脑上</li>
<li>在恢复的文件里执行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure></li>
<li>然后可以执行其他操作</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>eplan_harness_prod_学习笔记</title>
    <url>/2021/01/26/eplan-harness-prod-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>本人在学校车队项目负责线束部分，由于网络上较难找到相关资料，因此将学习笔记记录于此。</p>
</blockquote>
<span id="more"></span>

<hr>
<h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>EPLAN Harness prod是一款用于线束建模的软件。软件本身不复杂，但由于并不是广泛使用的软件，网络上学习的资源不多，学习阶段需要花点心思去研究，为新车进行线束建模的时候才会更加得心应手。</p>
<hr>
<h4 id="学习资源："><a href="#学习资源：" class="headerlink" title="学习资源："></a>学习资源：</h4><h6 id="网上资源：跟我一起学EPLAN-Harness-prod"><a href="#网上资源：跟我一起学EPLAN-Harness-prod" class="headerlink" title="网上资源：跟我一起学EPLAN Harness prod"></a><strong>网上资源：跟我一起学EPLAN Harness prod</strong></h6><p>点击链接进入话题 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&__biz=MzA3MjAzNTQ3OA==&scene=1&album_id=1446650997702623233&count=3&uin=&key=&devicetype=Windows+10+x64&version=63010043&lang=zh_CN&ascene=1&fontgear=2">#EPLAN教程</a> 查找 “<strong>跟我一起学EPLAN Harness prod</strong>”共七篇文章。文章内容没有完全的介绍软件的各部分功能，主要用于<strong>学习软件的基本操作</strong>以及<strong>初步了解建模步骤</strong>。</p>
<h6 id="书本：《EPLAN-Harness-prod-官方教程》"><a href="#书本：《EPLAN-Harness-prod-官方教程》" class="headerlink" title="书本：《EPLAN Harness prod 官方教程》"></a><strong>书本：《EPLAN Harness prod 官方教程》</strong></h6><p>对软件的介绍比较齐全，能够查找到软件上各个操作的使用方法。<strong>建模时候遇到问题可翻查此书寻找解决方法</strong>。<br><img src="https://img2.doubanio.com/view/subject/l/public/s33778793.jpg" alt="《EPLAN Harness prod 官方教程》"></p>
<hr>
<h4 id="学习过程："><a href="#学习过程：" class="headerlink" title="学习过程："></a>学习过程：</h4><h6 id="1、初步了解软"><a href="#1、初步了解软" class="headerlink" title="1、初步了解软"></a><strong>1、初步了解软</strong></h6><p>从软件自带的样本模型入手，结合教程（软件和教程的模型会不一样），初步了解建模的基本步骤以及基本操作，并尝试建模。</p>
<h6 id="2、尝试对上赛季模型进行线束建模并构思本赛季线束模型"><a href="#2、尝试对上赛季模型进行线束建模并构思本赛季线束模型" class="headerlink" title="2、尝试对上赛季模型进行线束建模并构思本赛季线束模型"></a><strong>2、尝试对上赛季模型进行线束建模并构思本赛季线束模型</strong></h6><p><strong>阅读赛规</strong>，看懂<strong>整车线束原理图</strong>（<u>重点：安全回路，结合赛规看</u>），<strong>研究上赛季线束模型</strong>，了解并整理<strong>各用电器接口及其位置</strong>。并根据本赛季模型的变化，查找相关线束建模资料（网络，其他优秀车队等），研究并思考如何优化布线。</p>
<hr>
<h4 id="基于对方程式赛车线束布置的一些注意点："><a href="#基于对方程式赛车线束布置的一些注意点：" class="headerlink" title="基于对方程式赛车线束布置的一些注意点："></a>基于对方程式赛车线束布置的一些注意点：</h4><p>1、    电源线要根据走的电流大小用线。（搜UL1007 线径和载流量对应表）<br>2、    信号线用20AWG。<br>3、    颜色上，<strong>供电线必须是红黑色，安全回路必须是黄色，高压线是橙色</strong>，其他颜色随便用。<br>4、    <strong>黄色和橙色是不能乱用的颜色。</strong><br>5、    CAN线的GND一定要在终端接地。<br>6、    CAN线尽量不要绕到大电池和电机控制器那边，会有很强的电磁干扰。<br>7、    主开关面板和主控接插件位置会汇聚很多线，也会有很多需要分线的地方，布置的时候就把分线的位置分布得均匀一点，以防出现线堆积过多。<br>8、    接插件分布要合理，如果一个地方有很多接插件，也会变成一大坨。<br>9、    关于导入模型。建议整车各部分模型分开导入，直接把整车模型导入模型会丢失。<br>10、    关于导入导线。对导线、管脚、连接物等命名尽量使用英文进行命名。导入导线时使用中文命名会出现乱码的现象。<br>11、    布线时不建议自动生成导线。手动布线会更加了解整体的走线情况。</p>
<blockquote>
<p>（学习阶段，若有补充，后续更新）</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>FSA</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32学习——PWM舵机控制</title>
    <url>/2020/12/02/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94PWM%E8%88%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h4 id="STM32控制舵机"><a href="#STM32控制舵机" class="headerlink" title="STM32控制舵机"></a>STM32控制舵机</h4><span id="more"></span>
<p>在STM32中控制舵机，实际上就是开发STM32上的PWM功能，这部分功能需要配置STM32的定时器和GPIO复用共功能，然后就是通过修改定时器计数器的比较寄存器的数值来达到控制PWM的高电平占空比的目的。</p>
<hr>
<p>(1) 定时器 IO 配置<br>(2) 定时器时基结构体 TIM_TimeBaseInitTypeDef 配置<br>(3) 定时器输出比较结构体 TIM_OCInitTypeDef 配置<br>(4) 定时器断路和死区结构体 TIM_BDTRInitTypeDef 配置</p>
<hr>
<h6 id="PWM-输出配置步骤（通过TIM1-CH1输出PWM来控舵机）"><a href="#PWM-输出配置步骤（通过TIM1-CH1输出PWM来控舵机）" class="headerlink" title="PWM 输出配置步骤（通过TIM1_CH1输出PWM来控舵机）"></a>PWM 输出配置步骤（通过TIM1_CH1输出PWM来控舵机）</h6><p><strong>1） 开启 TIM1 时钟，配置 PA8 为复用输出。</strong><br>要使用 TIM1，我们必须先开启 TIM1 的时钟，这里我们还要配置 PA8 为复用输出（当然还要时能 PORTA 的时钟），这是因为 TIM1_CH1 通道将使用 PA8 的复用功能作为输出。<br>库函数使能 TIM3 时钟的方法是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //使能定时器 3 时钟</span><br></pre></td></tr></table></figure>
<p>然后设置 PA8 为复用功能输出的。</p>
<p><strong>2）设置 TIM1 的 ARR 和 PSC。</strong><br>配置TIM_TimeBaseInitTypeDef结构体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TIM_TimeBaseStructure.TIM_Period = arr; //设置自动重装载值</span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置预分频值</span><br></pre></td></tr></table></figure>

<p><strong>3） 设置 TIM1_CH1 的 PWM 模式及通道方向, 使能 TIM1 的 CH1 输出。</strong><br>配置 TIM_OCInitTypeDef 结构体</p>
<p><strong>4） 使能 TIM1</strong><br>使能 TIM1 的方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TIM_Cmd(TIM1, ENABLE); //使能 TIM1</span><br></pre></td></tr></table></figure>

<p><strong>5） 设置 MOE 输出，使能 PWM 输出。（高级定时器才需要）</strong><br>普通定时器在完成以上设置了之后，就可以输出PWM了，但是高级定时器，我们还需要使能刹车和死区寄存器（ TIM1_BDTR）的 MOE 位，以使能整个 OCx（即 PWM）输出。<br>库数的设置函数为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TIM_CtrlPWMOutputs(TIM1,ENABLE);// MOE 主输出使能</span><br></pre></td></tr></table></figure>

<p><strong>6） 修改 TIM1_CCR1 来控制占空比</strong><br>最后，在经过以上设置之后， PWM 其实已经开始输出了，只是其占空比和频率都是固定的，而我们通过修改 TIM1_CCR1 则可以控制 CH1 的输出占空比。<br>在库函数中，修改 TIM1_CCR1 占空比的函数是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)；</span><br></pre></td></tr></table></figure>
<p>理所当然，对于其他通道，分别有一个函数名字，函数格式为 TIM_SetComparex(x=1,2,3,4)。</p>
<hr>
<h6 id="关于PWM"><a href="#关于PWM" class="headerlink" title="关于PWM"></a>关于PWM</h6><p><img src="https://s3.ax1x.com/2021/01/27/svcgVH.png" alt="TIM5"><br><img src="https://s3.ax1x.com/2021/01/27/svc6qe.png" alt="TIM4"><br><img src="https://s3.ax1x.com/2021/01/27/svcyrD.png" alt="TIM3"><br><img src="https://s3.ax1x.com/2021/01/27/svcDxK.png" alt="TIM2"><br><img src="https://s3.ax1x.com/2021/01/27/svc08x.png" alt="TIM1"></p>
<hr>
<h6 id="关于PB4引脚配置"><a href="#关于PB4引脚配置" class="headerlink" title="关于PB4引脚配置"></a>关于PB4引脚配置</h6><p>很多人遇到这种问题，但是应该注意的是PB4在单片机复位后，它是作为JTAG引脚来使用的，也就是说，要使用PB4你需要自己将其配置成普通GPIO.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE); </span><br></pre></td></tr></table></figure>
<p>配置成普通GPIO后，需要进行部分重映射.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3  , ENABLE);</span><br></pre></td></tr></table></figure>
<p>两步都完成后即可得到正常的PWM波输出</p>
<hr>
<h6 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &quot;timer.h&quot;</span></span><br><span class="line"><span class="comment">#include &quot;led.h&quot;</span></span><br><span class="line"><span class="comment">#include &quot;usart.h&quot;</span></span><br><span class="line">							  </span><br><span class="line">//通用定时器3中断初始化</span><br><span class="line">//这里时钟选择为APB1的2倍，而APB1为36M</span><br><span class="line">//arr：自动重装值。</span><br><span class="line">//psc：时钟预分频数</span><br><span class="line">//这里使用的是定时器3!</span><br><span class="line">void TIM3_Int_Init(u16 arr,u16 psc)</span><br><span class="line">&#123;</span><br><span class="line">  TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //时钟使能</span><br><span class="line"></span><br><span class="line">	TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值	 计数到5000为500ms</span><br><span class="line">	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值  10Khz的计数频率  </span><br><span class="line">	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim</span><br><span class="line">	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式</span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位</span><br><span class="line"> </span><br><span class="line">	TIM_ITConfig(TIM3,TIM_IT_Update,ENABLE ); //使能指定的TIM3中断,允许更新中断</span><br><span class="line"></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;  //TIM3中断</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;  //先占优先级0级</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;  //从优先级3级</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器</span><br><span class="line"></span><br><span class="line">	TIM_Cmd(TIM3, ENABLE);  //使能TIMx外设</span><br><span class="line">							 </span><br><span class="line">&#125;</span><br><span class="line">//定时器3中断服务程序</span><br><span class="line">void TIM3_IRQHandler(void)   //TIM3中断</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) //检查指定的TIM中断发生与否:TIM 中断源 </span><br><span class="line">		&#123;</span><br><span class="line">		TIM_ClearITPendingBit(TIM3, TIM_IT_Update  );  //清除TIMx的中断待处理位:TIM 中断源 </span><br><span class="line">		LED1=!LED1;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//TIM3 PWM部分初始化 </span><br><span class="line">//PWM输出初始化</span><br><span class="line">//arr：自动重装值</span><br><span class="line">//psc：时钟预分频数</span><br><span class="line">void TIM3_PWM_Init(u16 arr,u16 psc)</span><br><span class="line">&#123;  </span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">	TIM_OCInitTypeDef  TIM_OCInitStructure;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);	//使能定时器3时钟</span><br><span class="line"> 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB  | RCC_APB2Periph_AFIO, ENABLE);  //使能GPIO外设和AFIO复用功能模块时钟</span><br><span class="line">	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);</span><br><span class="line">	GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE); //Timer3部分重映射  TIM3_CH2-&gt;PB5    </span><br><span class="line"> </span><br><span class="line">   //设置该引脚为复用输出功能,输出TIM3 CH2的PWM脉冲波形	GPIOB.5</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4|GPIO_Pin_5; //TIM_CH2</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  //复用推挽输出</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);//初始化GPIO</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">   //初始化TIM3</span><br><span class="line">	TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值</span><br><span class="line">	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值 </span><br><span class="line">	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim</span><br><span class="line">	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式</span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//初始化TIM3 Channel1 PWM模式	 </span><br><span class="line">	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; //选择定时器模式:TIM脉冲宽度调制模式1</span><br><span class="line"> 	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能</span><br><span class="line">	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; //输出极性:TIM输出比较极性高</span><br><span class="line"></span><br><span class="line">	TIM_OC1Init(TIM3, &amp;TIM_OCInitStructure);  //根据T指定的参数初始化外设TIM3 OC1</span><br><span class="line">	TIM_OC1PreloadConfig(TIM3, TIM_OCPreload_Enable);  //使能TIM3在CCR1上的预装载寄存器</span><br><span class="line"> </span><br><span class="line">	TIM_OC2Init(TIM3, &amp;TIM_OCInitStructure);  //根据T指定的参数初始化外设TIM3 OC2</span><br><span class="line">	TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable);  //使能TIM3在CCR2上的预装载寄存器</span><br><span class="line"> </span><br><span class="line">	TIM_Cmd(TIM3, ENABLE);  //使能TIM3</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>STM32</tag>
        <tag>元器件</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32学习笔记——贪吃蛇</title>
    <url>/2020/09/18/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E8%B4%AA%E5%90%83%E8%9B%87/</url>
    <content><![CDATA[<h2 id="初学STM32。"><a href="#初学STM32。" class="headerlink" title="初学STM32。"></a>初学STM32。</h2><hr>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote>
<p>个人学单片机也有一段时间了，跟着教程学习，似乎掌握的不太熟练。偶然见到精品店里出售的迷你游戏机，决定尝试做一个贪吃蛇的小外设。制作过程收获颇多，在此做一个记录与分享。</p>
</blockquote>
<span id="more"></span>
<hr>
<h4 id="使用硬件"><a href="#使用硬件" class="headerlink" title="使用硬件"></a>使用硬件</h4><p>普通摇杆、0.96寸OLED屏幕（SPI协议通讯）、STM32F103RCT6开发板。<br><img src="https://s1.ax1x.com/2020/09/19/wI6IBj.jpg" alt="硬件"></p>
<hr>
<h4 id="接线"><a href="#接线" class="headerlink" title="接线"></a>接线</h4><table>
<thead>
<tr>
<th>OLED</th>
<th></th>
<th></th>
<th>摇杆</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>GND</td>
<td>GND</td>
<td></td>
<td>GND</td>
<td>GND</td>
</tr>
<tr>
<td>VCC</td>
<td>3.3V</td>
<td></td>
<td>VCC</td>
<td>3.3V</td>
</tr>
<tr>
<td>D0</td>
<td>PC0</td>
<td></td>
<td>VRX</td>
<td>PA0</td>
</tr>
<tr>
<td>D1</td>
<td>PC1</td>
<td></td>
<td>VRY</td>
<td>PA1</td>
</tr>
<tr>
<td>RES</td>
<td>PB15</td>
<td></td>
<td>SW</td>
<td>PA2</td>
</tr>
<tr>
<td>DC</td>
<td>PA3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CS</td>
<td>PA6</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://s1.ax1x.com/2020/09/19/wIf3nO.jpg" alt="接线"></p>
<hr>
<h4 id="游戏设计："><a href="#游戏设计：" class="headerlink" title="游戏设计："></a>游戏设计：</h4><p>主要分为前进、控制方向、生成苹果、吃苹果、蛇伸长、撞墙和撞蛇、计分、调速这几个功能。<br>摇杆上的杆用作控制方向，按键则用作调速。<br><img src="https://s1.ax1x.com/2020/09/19/wIW0w4.jpg" alt="游戏中"></p>
<hr>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><h5 id="一、初始化画面。"><a href="#一、初始化画面。" class="headerlink" title="一、初始化画面。"></a>一、初始化画面。</h5><p>将OLED显示屏分为信息栏部分和游戏显示部分。信息显示部分主要是显示分数和速度。游戏显示部分画出游戏区域框和蛇一开始的位置。<br>在我的设计里是用二维数组储存蛇的位置信息，我将蛇最大长度设为500（蛇长可以根据实际做修改），建立数组 snake[500][2]（snake[i][0]表示蛇x轴位置，snake[i][1]表示蛇y轴的位置）。snake[0]作为蛇尾，往后储存数据直到蛇头。建立蛇的备份数组用来储存初始化蛇的数据，便于用来初始化（<del>后来想想其实可以不用的</del>）。除了用数组储存蛇的数据以外，我在网上还见到用链表储存蛇的数据。（<del>初学C++，课堂上老师没教，不太会用，有空研究研究。</del>）</p>
<h5 id="二、蛇向前运动部分。"><a href="#二、蛇向前运动部分。" class="headerlink" title="二、蛇向前运动部分。"></a>二、蛇向前运动部分。</h5><p><strong>第一步</strong> 灭掉蛇尾（S[1]）的点<br><strong>第二步</strong> 更新蛇位置的数据，使得蛇前进<br><strong>第三步</strong> 点亮蛇头的点<br>只要不断更新，蛇就看起来在前进了。<br>下面是原理图<br><img src="https://s1.ax1x.com/2020/09/19/w5rcIf.jpg" alt="蛇前进原理图"></p>
<h6 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void Snake_move( void )</span><br><span class="line">&#123;</span><br><span class="line">	int i; </span><br><span class="line"></span><br><span class="line">	//灭掉蛇尾的点</span><br><span class="line">	Snake_drawpoint( snake[0][0], snake[0][1], 0 );</span><br><span class="line"></span><br><span class="line">	//前进</span><br><span class="line">	<span class="keyword">for</span> ( i = 0; i &lt; snake_long - 1 ; i++ )</span><br><span class="line">	&#123;</span><br><span class="line">		snake[i][0] = snake[i+1][0];</span><br><span class="line">		snake[i][1] = snake[i+1][1];</span><br><span class="line">	&#125;</span><br><span class="line">	snake[snake_long - 1][0] = snake[snake_long-1][0]+aim_x;</span><br><span class="line">	snake[snake_long - 1][1] = snake[snake_long-1][1]+aim_y;</span><br><span class="line"></span><br><span class="line">	//点亮蛇头的点</span><br><span class="line">	Snake_drawpoint ( snake[snake_long-1][0],snake[snake_long-1][1],1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、控制方向"><a href="#三、控制方向" class="headerlink" title="三、控制方向"></a>三、控制方向</h5><p>使用STM32的ADC功能获取摇杆x轴和y轴的数据，取合适的数据范围并作比较，更新前进方向。注意判断判断得到的前进方向与原方向相反时，不作方向的更新。</p>
<h6 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void Snake_control(void)</span><br><span class="line">&#123;</span><br><span class="line">	u16 x, y;</span><br><span class="line">	u16 x_jud, y_jud;</span><br><span class="line">	u16 tempx;</span><br><span class="line">	u16 tempy;</span><br><span class="line">	</span><br><span class="line">	//读取数据</span><br><span class="line">	tempx = Get_Adc_Average( ADC_Channel_0, 10);</span><br><span class="line">	tempy = Get_Adc_Average( ADC_Channel_1, 10);</span><br><span class="line">	x = tempx &gt;= 2048? (tempx - 2048) : (2048 - tempx);</span><br><span class="line">	y = tempy &gt;= 2048? (tempy - 2048) : (2048 - tempy);</span><br><span class="line">	x_jud = tempx &gt;= 2048? 1 : 0;</span><br><span class="line">	y_jud = tempy &gt;= 2048? 1 : 0;</span><br><span class="line">	</span><br><span class="line">	//确定方向</span><br><span class="line">	<span class="keyword">if</span>( x &gt; 1024 || y &gt; 1024 ) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( x &gt; y &amp;&amp; x_jud == 0 &amp;&amp; aim_x != 1) 	//向左</span><br><span class="line">		&#123;</span><br><span class="line">			aim_x = -1;</span><br><span class="line">			aim_y = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>( x &gt; y &amp;&amp; x_jud == 1 &amp;&amp; aim_x != -1)	//向右</span><br><span class="line">		&#123;</span><br><span class="line">			aim_x = 1;</span><br><span class="line">			aim_y = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>( y &gt; x &amp;&amp; y_jud == 0 &amp;&amp; aim_y != 1)	//向下</span><br><span class="line">		&#123;</span><br><span class="line">			aim_x = 0;</span><br><span class="line">			aim_y = -1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>( y &gt; x &amp;&amp; y_jud == 1 &amp;&amp; aim_y != -1)	//向上</span><br><span class="line">		&#123;</span><br><span class="line">			aim_x = 0;</span><br><span class="line">			aim_y = 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="四、生成苹果"><a href="#四、生成苹果" class="headerlink" title="四、生成苹果"></a>四、生成苹果</h5><p>利用单片机里的定时器中断服务程序生成随机数种子，然后使用 rand() 生成随机数作为苹果位置的数据。</p>
<h6 id="定时器中断服务函数"><a href="#定时器中断服务函数" class="headerlink" title="定时器中断服务函数"></a>定时器中断服务函数</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">u32 seed = 0;</span><br><span class="line">void TIM3_IRQHandler( void )   //TIM3中断</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)</span><br><span class="line">		&#123;</span><br><span class="line">			seed++;		//seed为随机数种子</span><br><span class="line">			TIM_ClearITPendingBit(TIM3, TIM_IT_Update  ); </span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="随机生成苹果"><a href="#随机生成苹果" class="headerlink" title="随机生成苹果"></a>随机生成苹果</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void Snake_apple (u32 seed)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	srand ( seed );</span><br><span class="line">	apple_x = rand() % 46 + 1;</span><br><span class="line">	apple_y = rand() % 30 + 1;</span><br><span class="line">	Snake_drawpoint ( apple_x, apple_y, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="五、吃苹果-amp-加分"><a href="#五、吃苹果-amp-加分" class="headerlink" title="五、吃苹果&amp;加分"></a>五、吃苹果&amp;加分</h5><p>判断蛇头（身体）坐标是否与苹果坐标相同。如果相同，且蛇长不超过最大值，则分数加一，蛇长加一。</p>
<h6 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void Snake_eatapple ( u32 seed )</span><br><span class="line">&#123;</span><br><span class="line">	u16 i;</span><br><span class="line">	<span class="keyword">for</span> ( i = 0; i &lt; snake_long; i++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (snake[i][0] == apple_x &amp;&amp; snake[i][1] == apple_y)</span><br><span class="line">		&#123;</span><br><span class="line">			score++;</span><br><span class="line">			<span class="keyword">if</span> (snake_long &lt; 500)</span><br><span class="line">			&#123;</span><br><span class="line">				snake_long = snake_long+1;</span><br><span class="line">				snake[snake_long-1][0] = snake[snake_long-2][0];</span><br><span class="line">				snake[snake_long-1][1] = snake[snake_long-2][1];</span><br><span class="line">			&#125;</span><br><span class="line">			OLED_ShowNum ( 96, 24, score, 4, 12);</span><br><span class="line">			Snake_apple (seed);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="六、蛇伸长"><a href="#六、蛇伸长" class="headerlink" title="六、蛇伸长"></a>六、蛇伸长</h5><p>在上面吃苹果的部分中，我将增加新蛇头的数据储存为旧蛇头的数据，（如图），此时的蛇被“折叠”起来，随着蛇不断前进，到一定步数后才会真正在屏幕上伸长。<br><img src="https://s1.ax1x.com/2020/09/19/w5r5ss.jpg" alt="蛇伸长原理"></p>
<h5 id="七、撞墙-amp-撞蛇身"><a href="#七、撞墙-amp-撞蛇身" class="headerlink" title="七、撞墙&amp;撞蛇身"></a>七、撞墙&amp;撞蛇身</h5><p>判断蛇头的坐标是否与墙坐标和蛇身坐标相同。相同则结束游戏，显示“GAMEOVER”，几秒后将所有数据初始化，游戏自动重新开始。<br><img src="https://s1.ax1x.com/2020/09/19/wIfFXT.jpg" alt="游戏结束"></p>
<h5 id="八、调速"><a href="#八、调速" class="headerlink" title="八、调速"></a>八、调速</h5><p>使用外部中断服务，读取按键情况。每按一下变化蛇的速度，显示在屏幕上。我将速度设为四挡从1-4为从慢到快。</p>
<h6 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">u32 speed = 320;</span><br><span class="line">void EXTI2_IRQHandler ( void )</span><br><span class="line">&#123;</span><br><span class="line">	delay_ms( 10 );</span><br><span class="line">	<span class="keyword">if</span> ( KEY1 == 0 )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ( speed &gt; 20 )</span><br><span class="line">			speed -= 100;</span><br><span class="line">		<span class="keyword">else</span> speed = 320;</span><br><span class="line">		OLED_ShowNum ( 96, 48, 4 - speed / 100, 4, 12);</span><br><span class="line">	&#125;		 </span><br><span class="line">	EXTI_ClearITPendingBit ( EXTI_Line2 ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="一些问题与想法"><a href="#一些问题与想法" class="headerlink" title="一些问题与想法"></a>一些问题与想法</h4><ul>
<li>没有设置控制游戏开始结束的按键。</li>
<li>使用摇杆时，由于摇杆过于灵活，有时候控制不好会出现蛇走的方向不受控制。</li>
<li>生成苹果时没有考虑消除苹果生成在蛇内部。为了减少麻烦，我是直接将判断苹果是不是在蛇内部，直接计分。</li>
<li>此时出现了一个问题，我一开始时是将吃苹果后苹果的坐标作为新蛇头，但如果苹果出现在蛇内部，就会出现蛇（<del>莫名其妙</del>）撞到自己（蛇头坐标等于蛇身坐标）。所以讲新蛇头设置为与旧蛇头一样的坐标。（与正常情况苹果生成在蛇外部是一样的）</li>
<li>优化：设置按键控制游戏开始结束、用按键控制蛇方向。</li>
<li>尝试：使用链表储存蛇数据、设置迷宫型地图。</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
</search>
